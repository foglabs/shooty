<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Shooty Blasters</title>
    <link href="game.css" rel="stylesheet">
  </head>

  <body>
    <div id="info">
      <div class="bar-ele" id="score"></div>
      <div class="bar-ele">
        <progress id="power" value="10" max="100"></progress>
      </div>
      <div class="bar-ele" id="timer"></div>
    </div>

    <script src="three.js"></script>
    <script src="classes/game.js"></script>
    <script src="classes/timer.js"></script>
    <script src="classes/character.js"></script>
    <script src="classes/player.js"></script>
    <script src="classes/enemy.js"></script>
    <script>
      // run every frame
      function animate() {
        if(!enemyTimer.running){
          enemyTimer.start()
        }

        let remaining = enemyTimer.time()
        game.drawTimer(remaining)

        if(remaining == 0 ){

          game.generateEnemies( Math.round(Math.random() * 50) )

          enemyTimer.reset()
        }

        player.handleMovement()

        game.moveEnemies()
        game.handleLife()
        game.handleCorruption()

        player.animation()

        game.drawScore()
        game.drawPower()

        requestAnimationFrame( animate )
        // draw de cool scene
        renderer.render( scene, camera )
        // clear de buff
        // for the HUD
        renderer.render(sceneHUD, cameraHUD)
      }

      // scene contains objects
      var scene = new THREE.Scene();
      // scene.background = new THREE.Color( 0xffffff )


      // load this crap here so we only do it once
      let spriteMaterial
      let loader = new THREE.TextureLoader()
      console.log( 'helloooo' )
      let spriteMap = loader.load( "sprites/sprite2.png",
        (tx) => {  console.log( 'success!' )  },
        null,
        (err) => { console.log( 'i fucked way up ' ); console.log( err)}
       )
      spriteMaterial = new THREE.SpriteMaterial( { map: spriteMap } )
      
      // camera is passed into renderer, rather than as scene object
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
      camera.position.z = 5;

      // this is for the gui
      let width = window.innerWidth
      let height = window.innerHeight

      let hudCanvas = document.createElement('canvas')
      hudCanvas.width = width
      hudCanvas.height = height
      let hudBitmap = hudCanvas.getContext('2d');
      // hudBitmap.font = "Normal 40px Arial";
      // hudBitmap.bottom = 0
      // hudBitmap.textAlign = 'center';
      // hudBitmap.fillStyle = "rgba(245,245,245,0.75)";
      // hudBitmap.fillText('0 0 0 0 0', width / 2, height-20);
      // let gr = hudBitmap.createRadialGradient(110,90,30, 100,100,70);
      // gr.addColorStop(0, 'pink');
      // gr.addColorStop(.9, 'white');
      // gr.addColorStop(1, 'green');
      // hudBitmap.fillStyle = gr
      
      var cameraHUD = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 0, 30 );
      sceneHUD = new THREE.Scene();
      var hudTexture = new THREE.Texture(hudCanvas) 
      hudTexture.needsUpdate = true;
      var material = new THREE.MeshBasicMaterial( {map: hudTexture} );
      material.transparent = true;
      
      var planeGeometry = new THREE.PlaneGeometry( width, height );
      var plane = new THREE.Mesh( planeGeometry, material );
      sceneHUD.add( plane );

      let game = new Game()

      // countdown to generate enemies every so often
      let enemyTimer = new Timer(5000)


      let player = new Player([22,88,49])

      scene.add( player.mesh );
      // create bounding box object for intersection

      // // add grid
      var size = 10;
      var divisions = 10;
      var gridHelper = new THREE.GridHelper( size, divisions );
      gridHelper.rotation.x = 80;
      scene.add( gridHelper );

      // render has the beef (webgl) to draw each frame
      var renderer = new THREE.WebGLRenderer();
      renderer.autoClear = false
      renderer.setSize( window.innerWidth, window.innerHeight );
      // renderer.setClearColor( 0xffffff, 0 );

      animate();

      document.addEventListener("keydown", onDocumentKeyDownUp, false);
      document.addEventListener("keyup", onDocumentKeyDownUp, false);
      function changeSpeed(key){
        if (key == "ArrowLeft") {
            // console.log("left")
            player.accx -= 0.5;
        } else if (key == "ArrowUp") {
            // console.log("up")
            player.accy += 0.5;
        } else if (key == "ArrowRight") {
            // console.log("right")
            player.accx += 0.5;
        } else if (key == "ArrowDown") {
            // console.log("down")
            player.accy   -= 0.5;
        } else if (key == 32) {
            // console.log("fuck")
            playercube.position.set(0, 0, 0);
        }

      }
      let heldkeys = {};
      function onDocumentKeyDownUp(event) {
        heldkeys[event.key] = event.type == 'keydown';
        
        heldkeys_keys = Object.keys(heldkeys)

        // are any keys held down 
        if(heldkeys_keys){
          for(i=0; i<heldkeys_keys.length; i++){
            // is the key held down?
            let key = heldkeys_keys[i];
            if(heldkeys[key]){
              changeSpeed(event.key)
            }
          }
        }
        
        // console.log("playercube position is")
        // console.log(playercube.position)
      }

      document.body.appendChild( renderer.domElement )
    </script>

  </body>
</html>

